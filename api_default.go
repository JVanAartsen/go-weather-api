/*
weather.gov API

weather.gov API

API version: 1.8.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package weatherApi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
	"os"
)


type DefaultApi interface {

	/*
	AlertsActive Method for AlertsActive

	Returns all currently active alerts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsActiveRequest
	*/
	AlertsActive(ctx context.Context) ApiAlertsActiveRequest

	// AlertsActiveExecute executes the request
	//  @return AlertCollectionGeoJson
	AlertsActiveExecute(r ApiAlertsActiveRequest) (*AlertCollectionGeoJson, *http.Response, error)

	/*
	AlertsActiveArea Method for AlertsActiveArea

	Returns active alerts for the given area (state or marine area)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param area State/area ID
	@return ApiAlertsActiveAreaRequest
	*/
	AlertsActiveArea(ctx context.Context, area AreaCode) ApiAlertsActiveAreaRequest

	// AlertsActiveAreaExecute executes the request
	//  @return AlertCollectionGeoJson
	AlertsActiveAreaExecute(r ApiAlertsActiveAreaRequest) (*AlertCollectionGeoJson, *http.Response, error)

	/*
	AlertsActiveCount Method for AlertsActiveCount

	Returns info on the number of active alerts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsActiveCountRequest
	*/
	AlertsActiveCount(ctx context.Context) ApiAlertsActiveCountRequest

	// AlertsActiveCountExecute executes the request
	//  @return AlertsActiveCount200Response
	AlertsActiveCountExecute(r ApiAlertsActiveCountRequest) (*AlertsActiveCount200Response, *http.Response, error)

	/*
	AlertsActiveRegion Method for AlertsActiveRegion

	Returns active alerts for the given marine region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region Marine region ID
	@return ApiAlertsActiveRegionRequest
	*/
	AlertsActiveRegion(ctx context.Context, region MarineRegionCode) ApiAlertsActiveRegionRequest

	// AlertsActiveRegionExecute executes the request
	//  @return AlertCollectionGeoJson
	AlertsActiveRegionExecute(r ApiAlertsActiveRegionRequest) (*AlertCollectionGeoJson, *http.Response, error)

	/*
	AlertsActiveZone Method for AlertsActiveZone

	Returns active alerts for the given NWS public zone or county

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param zoneId NWS public zone/county identifier
	@return ApiAlertsActiveZoneRequest
	*/
	AlertsActiveZone(ctx context.Context, zoneId string) ApiAlertsActiveZoneRequest

	// AlertsActiveZoneExecute executes the request
	//  @return AlertCollectionGeoJson
	AlertsActiveZoneExecute(r ApiAlertsActiveZoneRequest) (*AlertCollectionGeoJson, *http.Response, error)

	/*
	AlertsQuery Method for AlertsQuery

	Returns all alerts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsQueryRequest
	*/
	AlertsQuery(ctx context.Context) ApiAlertsQueryRequest

	// AlertsQueryExecute executes the request
	//  @return AlertCollectionGeoJson
	AlertsQueryExecute(r ApiAlertsQueryRequest) (*AlertCollectionGeoJson, *http.Response, error)

	/*
	AlertsSingle Method for AlertsSingle

	Returns a specific alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Alert identifier
	@return ApiAlertsSingleRequest
	*/
	AlertsSingle(ctx context.Context, id string) ApiAlertsSingleRequest

	// AlertsSingleExecute executes the request
	//  @return AlertGeoJson
	AlertsSingleExecute(r ApiAlertsSingleRequest) (*AlertGeoJson, *http.Response, error)

	/*
	AlertsTypes Method for AlertsTypes

	Returns a list of alert types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsTypesRequest
	*/
	AlertsTypes(ctx context.Context) ApiAlertsTypesRequest

	// AlertsTypesExecute executes the request
	//  @return AlertsTypes200Response
	AlertsTypesExecute(r ApiAlertsTypesRequest) (*AlertsTypes200Response, *http.Response, error)

	/*
	Glossary Method for Glossary

	Returns glossary terms

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGlossaryRequest
	*/
	Glossary(ctx context.Context) ApiGlossaryRequest

	// GlossaryExecute executes the request
	//  @return Glossary200Response
	GlossaryExecute(r ApiGlossaryRequest) (*Glossary200Response, *http.Response, error)

	/*
	Gridpoint Method for Gridpoint

	Returns raw numerical forecast data for a 2.5km grid area

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param wfo Forecast office ID
	@param x Forecast grid X coordinate
	@param y Forecast grid Y coordinate
	@return ApiGridpointRequest
	*/
	Gridpoint(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointRequest

	// GridpointExecute executes the request
	//  @return GridpointGeoJson
	GridpointExecute(r ApiGridpointRequest) (*GridpointGeoJson, *http.Response, error)

	/*
	GridpointForecast Method for GridpointForecast

	Returns a textual forecast for a 2.5km grid area

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param wfo Forecast office ID
	@param x Forecast grid X coordinate
	@param y Forecast grid Y coordinate
	@return ApiGridpointForecastRequest
	*/
	GridpointForecast(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointForecastRequest

	// GridpointForecastExecute executes the request
	//  @return GridpointForecastGeoJson
	GridpointForecastExecute(r ApiGridpointForecastRequest) (*GridpointForecastGeoJson, *http.Response, error)

	/*
	GridpointForecastHourly Method for GridpointForecastHourly

	Returns a textual hourly forecast for a 2.5km grid area

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param wfo Forecast office ID
	@param x Forecast grid X coordinate
	@param y Forecast grid Y coordinate
	@return ApiGridpointForecastHourlyRequest
	*/
	GridpointForecastHourly(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointForecastHourlyRequest

	// GridpointForecastHourlyExecute executes the request
	//  @return GridpointForecastGeoJson
	GridpointForecastHourlyExecute(r ApiGridpointForecastHourlyRequest) (*GridpointForecastGeoJson, *http.Response, error)

	/*
	GridpointStations Method for GridpointStations

	Returns a list of observation stations usable for a given 2.5km grid area

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param wfo Forecast office ID
	@param x Forecast grid X coordinate
	@param y Forecast grid Y coordinate
	@return ApiGridpointStationsRequest
	*/
	GridpointStations(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointStationsRequest

	// GridpointStationsExecute executes the request
	//  @return ObservationStationCollectionGeoJson
	GridpointStationsExecute(r ApiGridpointStationsRequest) (*ObservationStationCollectionGeoJson, *http.Response, error)

	/*
	Icons Method for Icons

	Returns a forecast icon. Icon services in API are deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param set .
	@param timeOfDay .
	@param first .
	@return ApiIconsRequest

	Deprecated
	*/
	Icons(ctx context.Context, set string, timeOfDay string, first string) ApiIconsRequest

	// IconsExecute executes the request
	//  @return *os.File
	// Deprecated
	IconsExecute(r ApiIconsRequest) (**os.File, *http.Response, error)

	/*
	IconsDualCondition Method for IconsDualCondition

	Returns a forecast icon. Icon services in API are deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param set .
	@param timeOfDay .
	@param first .
	@param second .
	@return ApiIconsDualConditionRequest

	Deprecated
	*/
	IconsDualCondition(ctx context.Context, set string, timeOfDay string, first string, second string) ApiIconsDualConditionRequest

	// IconsDualConditionExecute executes the request
	//  @return *os.File
	// Deprecated
	IconsDualConditionExecute(r ApiIconsDualConditionRequest) (**os.File, *http.Response, error)

	/*
	IconsSummary Method for IconsSummary

	Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIconsSummaryRequest

	Deprecated
	*/
	IconsSummary(ctx context.Context) ApiIconsSummaryRequest

	// IconsSummaryExecute executes the request
	//  @return IconsSummary200Response
	// Deprecated
	IconsSummaryExecute(r ApiIconsSummaryRequest) (*IconsSummary200Response, *http.Response, error)

	/*
	LocationProducts Method for LocationProducts

	Returns a list of valid text product types for a given issuance location

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locationId .
	@return ApiLocationProductsRequest
	*/
	LocationProducts(ctx context.Context, locationId string) ApiLocationProductsRequest

	// LocationProductsExecute executes the request
	//  @return TextProductTypeCollection
	LocationProductsExecute(r ApiLocationProductsRequest) (*TextProductTypeCollection, *http.Response, error)

	/*
	ObsStation Method for ObsStation

	Returns metadata about a given observation station

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Observation station ID
	@return ApiObsStationRequest
	*/
	ObsStation(ctx context.Context, stationId string) ApiObsStationRequest

	// ObsStationExecute executes the request
	//  @return ObservationStationGeoJson
	ObsStationExecute(r ApiObsStationRequest) (*ObservationStationGeoJson, *http.Response, error)

	/*
	ObsStations Method for ObsStations

	Returns a list of observation stations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiObsStationsRequest
	*/
	ObsStations(ctx context.Context) ApiObsStationsRequest

	// ObsStationsExecute executes the request
	//  @return ObservationStationCollectionGeoJson
	ObsStationsExecute(r ApiObsStationsRequest) (*ObservationStationCollectionGeoJson, *http.Response, error)

	/*
	Office Method for Office

	Returns metadata about a NWS forecast office

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param officeId NWS forecast office ID
	@return ApiOfficeRequest
	*/
	Office(ctx context.Context, officeId NWSForecastOfficeId) ApiOfficeRequest

	// OfficeExecute executes the request
	//  @return Office
	OfficeExecute(r ApiOfficeRequest) (*Office, *http.Response, error)

	/*
	OfficeHeadline Method for OfficeHeadline

	Returns a specific news headline for a given NWS office

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param officeId NWS forecast office ID
	@param headlineId Headline record ID
	@return ApiOfficeHeadlineRequest
	*/
	OfficeHeadline(ctx context.Context, officeId NWSForecastOfficeId, headlineId string) ApiOfficeHeadlineRequest

	// OfficeHeadlineExecute executes the request
	//  @return OfficeHeadline
	OfficeHeadlineExecute(r ApiOfficeHeadlineRequest) (*OfficeHeadline, *http.Response, error)

	/*
	OfficeHeadlines Method for OfficeHeadlines

	Returns a list of news headlines for a given NWS office

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param officeId NWS forecast office ID
	@return ApiOfficeHeadlinesRequest
	*/
	OfficeHeadlines(ctx context.Context, officeId NWSForecastOfficeId) ApiOfficeHeadlinesRequest

	// OfficeHeadlinesExecute executes the request
	//  @return OfficeHeadlineCollection
	OfficeHeadlinesExecute(r ApiOfficeHeadlinesRequest) (*OfficeHeadlineCollection, *http.Response, error)

	/*
	Point Method for Point

	Returns metadata about a given latitude/longitude point

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param point Point (latitude, longitude)
	@return ApiPointRequest
	*/
	Point(ctx context.Context, point string) ApiPointRequest

	// PointExecute executes the request
	//  @return PointGeoJson
	PointExecute(r ApiPointRequest) (*PointGeoJson, *http.Response, error)

	/*
	PointStations Method for PointStations

	Returns a list of observation stations for a given point

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param point Point (latitude, longitude)
	@return ApiPointStationsRequest

	Deprecated
	*/
	PointStations(ctx context.Context, point string) ApiPointStationsRequest

	// PointStationsExecute executes the request
	//  @return ProblemDetail
	// Deprecated
	PointStationsExecute(r ApiPointStationsRequest) (*ProblemDetail, *http.Response, error)

	/*
	Product Method for Product

	Returns a specific text product

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param productId .
	@return ApiProductRequest
	*/
	Product(ctx context.Context, productId string) ApiProductRequest

	// ProductExecute executes the request
	//  @return TextProduct
	ProductExecute(r ApiProductRequest) (*TextProduct, *http.Response, error)

	/*
	ProductLocations Method for ProductLocations

	Returns a list of valid text product issuance locations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProductLocationsRequest
	*/
	ProductLocations(ctx context.Context) ApiProductLocationsRequest

	// ProductLocationsExecute executes the request
	//  @return TextProductLocationCollection
	ProductLocationsExecute(r ApiProductLocationsRequest) (*TextProductLocationCollection, *http.Response, error)

	/*
	ProductTypes Method for ProductTypes

	Returns a list of valid text product types and codes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProductTypesRequest
	*/
	ProductTypes(ctx context.Context) ApiProductTypesRequest

	// ProductTypesExecute executes the request
	//  @return TextProductTypeCollection
	ProductTypesExecute(r ApiProductTypesRequest) (*TextProductTypeCollection, *http.Response, error)

	/*
	ProductsQuery Method for ProductsQuery

	Returns a list of text products

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProductsQueryRequest
	*/
	ProductsQuery(ctx context.Context) ApiProductsQueryRequest

	// ProductsQueryExecute executes the request
	//  @return TextProductCollection
	ProductsQueryExecute(r ApiProductsQueryRequest) (*TextProductCollection, *http.Response, error)

	/*
	ProductsType Method for ProductsType

	Returns a list of text products of a given type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId .
	@return ApiProductsTypeRequest
	*/
	ProductsType(ctx context.Context, typeId string) ApiProductsTypeRequest

	// ProductsTypeExecute executes the request
	//  @return TextProductCollection
	ProductsTypeExecute(r ApiProductsTypeRequest) (*TextProductCollection, *http.Response, error)

	/*
	ProductsTypeLocation Method for ProductsTypeLocation

	Returns a list of text products of a given type for a given issuance location

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId .
	@param locationId .
	@return ApiProductsTypeLocationRequest
	*/
	ProductsTypeLocation(ctx context.Context, typeId string, locationId string) ApiProductsTypeLocationRequest

	// ProductsTypeLocationExecute executes the request
	//  @return TextProductCollection
	ProductsTypeLocationExecute(r ApiProductsTypeLocationRequest) (*TextProductCollection, *http.Response, error)

	/*
	ProductsTypeLocations Method for ProductsTypeLocations

	Returns a list of valid text product issuance locations for a given product type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId .
	@return ApiProductsTypeLocationsRequest
	*/
	ProductsTypeLocations(ctx context.Context, typeId string) ApiProductsTypeLocationsRequest

	// ProductsTypeLocationsExecute executes the request
	//  @return TextProductLocationCollection
	ProductsTypeLocationsExecute(r ApiProductsTypeLocationsRequest) (*TextProductLocationCollection, *http.Response, error)

	/*
	RadarProfiler Method for RadarProfiler

	Returns metadata about a given radar wind profiler

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Profiler station ID
	@return ApiRadarProfilerRequest
	*/
	RadarProfiler(ctx context.Context, stationId string) ApiRadarProfilerRequest

	// RadarProfilerExecute executes the request
	RadarProfilerExecute(r ApiRadarProfilerRequest) (*http.Response, error)

	/*
	RadarQueue Method for RadarQueue

	Returns metadata about a given radar queue

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param host LDM host
	@return ApiRadarQueueRequest
	*/
	RadarQueue(ctx context.Context, host string) ApiRadarQueueRequest

	// RadarQueueExecute executes the request
	RadarQueueExecute(r ApiRadarQueueRequest) (*http.Response, error)

	/*
	RadarServer Method for RadarServer

	Returns metadata about a given radar server

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Server ID
	@return ApiRadarServerRequest
	*/
	RadarServer(ctx context.Context, id string) ApiRadarServerRequest

	// RadarServerExecute executes the request
	RadarServerExecute(r ApiRadarServerRequest) (*http.Response, error)

	/*
	RadarServers Method for RadarServers

	Returns a list of radar servers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRadarServersRequest
	*/
	RadarServers(ctx context.Context) ApiRadarServersRequest

	// RadarServersExecute executes the request
	RadarServersExecute(r ApiRadarServersRequest) (*http.Response, error)

	/*
	RadarStation Method for RadarStation

	Returns metadata about a given radar station

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Radar station ID
	@return ApiRadarStationRequest
	*/
	RadarStation(ctx context.Context, stationId string) ApiRadarStationRequest

	// RadarStationExecute executes the request
	RadarStationExecute(r ApiRadarStationRequest) (*http.Response, error)

	/*
	RadarStationAlarms Method for RadarStationAlarms

	Returns metadata about a given radar station alarms

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Radar station ID
	@return ApiRadarStationAlarmsRequest
	*/
	RadarStationAlarms(ctx context.Context, stationId string) ApiRadarStationAlarmsRequest

	// RadarStationAlarmsExecute executes the request
	RadarStationAlarmsExecute(r ApiRadarStationAlarmsRequest) (*http.Response, error)

	/*
	RadarStations Method for RadarStations

	Returns a list of radar stations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRadarStationsRequest
	*/
	RadarStations(ctx context.Context) ApiRadarStationsRequest

	// RadarStationsExecute executes the request
	RadarStationsExecute(r ApiRadarStationsRequest) (*http.Response, error)

	/*
	SatelliteThumbnails Method for SatelliteThumbnails

	Returns a thumbnail image for a satellite region. Image services in API are deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param area .
	@return ApiSatelliteThumbnailsRequest

	Deprecated
	*/
	SatelliteThumbnails(ctx context.Context, area string) ApiSatelliteThumbnailsRequest

	// SatelliteThumbnailsExecute executes the request
	//  @return *os.File
	// Deprecated
	SatelliteThumbnailsExecute(r ApiSatelliteThumbnailsRequest) (**os.File, *http.Response, error)

	/*
	StationObservationLatest Method for StationObservationLatest

	Returns the latest observation for a station

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Observation station ID
	@return ApiStationObservationLatestRequest
	*/
	StationObservationLatest(ctx context.Context, stationId string) ApiStationObservationLatestRequest

	// StationObservationLatestExecute executes the request
	//  @return ObservationGeoJson
	StationObservationLatestExecute(r ApiStationObservationLatestRequest) (*ObservationGeoJson, *http.Response, error)

	/*
	StationObservationList Method for StationObservationList

	Returns a list of observations for a given station

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Observation station ID
	@return ApiStationObservationListRequest
	*/
	StationObservationList(ctx context.Context, stationId string) ApiStationObservationListRequest

	// StationObservationListExecute executes the request
	//  @return ObservationCollectionGeoJson
	StationObservationListExecute(r ApiStationObservationListRequest) (*ObservationCollectionGeoJson, *http.Response, error)

	/*
	StationObservationTime Method for StationObservationTime

	Returns a single observation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId Observation station ID
	@param time Timestamp of requested observation
	@return ApiStationObservationTimeRequest
	*/
	StationObservationTime(ctx context.Context, stationId string, time time.Time) ApiStationObservationTimeRequest

	// StationObservationTimeExecute executes the request
	//  @return ObservationGeoJson
	StationObservationTimeExecute(r ApiStationObservationTimeRequest) (*ObservationGeoJson, *http.Response, error)

	/*
	Zone Method for Zone

	Returns metadata about a given zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param type_ Zone type
	@param zoneId NWS public zone/county identifier
	@return ApiZoneRequest
	*/
	Zone(ctx context.Context, type_ string, zoneId string) ApiZoneRequest

	// ZoneExecute executes the request
	//  @return ZoneGeoJson
	ZoneExecute(r ApiZoneRequest) (*ZoneGeoJson, *http.Response, error)

	/*
	ZoneForecast Method for ZoneForecast

	Returns the current zone forecast for a given zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param type_ Zone type
	@param zoneId NWS public zone/county identifier
	@return ApiZoneForecastRequest
	*/
	ZoneForecast(ctx context.Context, type_ string, zoneId string) ApiZoneForecastRequest

	// ZoneForecastExecute executes the request
	//  @return ZoneForecastGeoJson
	ZoneForecastExecute(r ApiZoneForecastRequest) (*ZoneForecastGeoJson, *http.Response, error)

	/*
	ZoneList Method for ZoneList

	Returns a list of zones

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiZoneListRequest
	*/
	ZoneList(ctx context.Context) ApiZoneListRequest

	// ZoneListExecute executes the request
	//  @return ZoneCollectionGeoJson
	ZoneListExecute(r ApiZoneListRequest) (*ZoneCollectionGeoJson, *http.Response, error)

	/*
	ZoneListType Method for ZoneListType

	Returns a list of zones of a given type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param type_ Zone type
	@return ApiZoneListTypeRequest
	*/
	ZoneListType(ctx context.Context, type_ string) ApiZoneListTypeRequest

	// ZoneListTypeExecute executes the request
	//  @return ZoneCollectionGeoJson
	ZoneListTypeExecute(r ApiZoneListTypeRequest) (*ZoneCollectionGeoJson, *http.Response, error)

	/*
	ZoneObs Method for ZoneObs

	Returns a list of observations for a given zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param zoneId NWS public zone/county identifier
	@return ApiZoneObsRequest
	*/
	ZoneObs(ctx context.Context, zoneId string) ApiZoneObsRequest

	// ZoneObsExecute executes the request
	//  @return ObservationCollectionGeoJson
	ZoneObsExecute(r ApiZoneObsRequest) (*ObservationCollectionGeoJson, *http.Response, error)

	/*
	ZoneStations Method for ZoneStations

	Returns a list of observation stations for a given zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param zoneId NWS public zone/county identifier
	@return ApiZoneStationsRequest
	*/
	ZoneStations(ctx context.Context, zoneId string) ApiZoneStationsRequest

	// ZoneStationsExecute executes the request
	//  @return ObservationStationCollectionGeoJson
	ZoneStationsExecute(r ApiZoneStationsRequest) (*ObservationStationCollectionGeoJson, *http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAlertsActiveRequest struct {
	ctx context.Context
	ApiService DefaultApi
	status *[]string
	messageType *[]string
	event *[]string
	code *[]string
	area *[]AreaCode
	point *string
	region *[]MarineRegionCode
	regionType *string
	zone *[]string
	urgency *[]AlertUrgency
	severity *[]AlertSeverity
	certainty *[]AlertCertainty
	limit *int32
}

// Status (actual, exercise, system, test, draft)
func (r ApiAlertsActiveRequest) Status(status []string) ApiAlertsActiveRequest {
	r.status = &status
	return r
}

// Message type (alert, update, cancel)
func (r ApiAlertsActiveRequest) MessageType(messageType []string) ApiAlertsActiveRequest {
	r.messageType = &messageType
	return r
}

// Event name
func (r ApiAlertsActiveRequest) Event(event []string) ApiAlertsActiveRequest {
	r.event = &event
	return r
}

// Event code
func (r ApiAlertsActiveRequest) Code(code []string) ApiAlertsActiveRequest {
	r.code = &code
	return r
}

// State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
func (r ApiAlertsActiveRequest) Area(area []AreaCode) ApiAlertsActiveRequest {
	r.area = &area
	return r
}

// Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
func (r ApiAlertsActiveRequest) Point(point string) ApiAlertsActiveRequest {
	r.point = &point
	return r
}

// Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
func (r ApiAlertsActiveRequest) Region(region []MarineRegionCode) ApiAlertsActiveRequest {
	r.region = &region
	return r
}

// Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
func (r ApiAlertsActiveRequest) RegionType(regionType string) ApiAlertsActiveRequest {
	r.regionType = &regionType
	return r
}

// Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
func (r ApiAlertsActiveRequest) Zone(zone []string) ApiAlertsActiveRequest {
	r.zone = &zone
	return r
}

// Urgency (immediate, expected, future, past, unknown)
func (r ApiAlertsActiveRequest) Urgency(urgency []AlertUrgency) ApiAlertsActiveRequest {
	r.urgency = &urgency
	return r
}

// Severity (extreme, severe, moderate, minor, unknown)
func (r ApiAlertsActiveRequest) Severity(severity []AlertSeverity) ApiAlertsActiveRequest {
	r.severity = &severity
	return r
}

// Certainty (observed, likely, possible, unlikely, unknown)
func (r ApiAlertsActiveRequest) Certainty(certainty []AlertCertainty) ApiAlertsActiveRequest {
	r.certainty = &certainty
	return r
}

// Limit
func (r ApiAlertsActiveRequest) Limit(limit int32) ApiAlertsActiveRequest {
	r.limit = &limit
	return r
}

func (r ApiAlertsActiveRequest) Execute() (*AlertCollectionGeoJson, *http.Response, error) {
	return r.ApiService.AlertsActiveExecute(r)
}

/*
AlertsActive Method for AlertsActive

Returns all currently active alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertsActiveRequest
*/
func (a *DefaultApiService) AlertsActive(ctx context.Context) ApiAlertsActiveRequest {
	return ApiAlertsActiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertCollectionGeoJson
func (a *DefaultApiService) AlertsActiveExecute(r ApiAlertsActiveRequest) (*AlertCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsActive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, "csv"))
	}
	if r.messageType != nil {
		localVarQueryParams.Add("message_type", parameterToString(*r.messageType, "csv"))
	}
	if r.event != nil {
		localVarQueryParams.Add("event", parameterToString(*r.event, "csv"))
	}
	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, "csv"))
	}
	if r.area != nil {
		localVarQueryParams.Add("area", parameterToString(*r.area, "csv"))
	}
	if r.point != nil {
		localVarQueryParams.Add("point", parameterToString(*r.point, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, "csv"))
	}
	if r.regionType != nil {
		localVarQueryParams.Add("region_type", parameterToString(*r.regionType, ""))
	}
	if r.zone != nil {
		localVarQueryParams.Add("zone", parameterToString(*r.zone, "csv"))
	}
	if r.urgency != nil {
		localVarQueryParams.Add("urgency", parameterToString(*r.urgency, "csv"))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, "csv"))
	}
	if r.certainty != nil {
		localVarQueryParams.Add("certainty", parameterToString(*r.certainty, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/atom+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsActiveAreaRequest struct {
	ctx context.Context
	ApiService DefaultApi
	area AreaCode
}

func (r ApiAlertsActiveAreaRequest) Execute() (*AlertCollectionGeoJson, *http.Response, error) {
	return r.ApiService.AlertsActiveAreaExecute(r)
}

/*
AlertsActiveArea Method for AlertsActiveArea

Returns active alerts for the given area (state or marine area)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param area State/area ID
 @return ApiAlertsActiveAreaRequest
*/
func (a *DefaultApiService) AlertsActiveArea(ctx context.Context, area AreaCode) ApiAlertsActiveAreaRequest {
	return ApiAlertsActiveAreaRequest{
		ApiService: a,
		ctx: ctx,
		area: area,
	}
}

// Execute executes the request
//  @return AlertCollectionGeoJson
func (a *DefaultApiService) AlertsActiveAreaExecute(r ApiAlertsActiveAreaRequest) (*AlertCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsActiveArea")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/active/area/{area}"
	localVarPath = strings.Replace(localVarPath, "{"+"area"+"}", url.PathEscape(parameterToString(r.area, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/atom+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsActiveCountRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiAlertsActiveCountRequest) Execute() (*AlertsActiveCount200Response, *http.Response, error) {
	return r.ApiService.AlertsActiveCountExecute(r)
}

/*
AlertsActiveCount Method for AlertsActiveCount

Returns info on the number of active alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertsActiveCountRequest
*/
func (a *DefaultApiService) AlertsActiveCount(ctx context.Context) ApiAlertsActiveCountRequest {
	return ApiAlertsActiveCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertsActiveCount200Response
func (a *DefaultApiService) AlertsActiveCountExecute(r ApiAlertsActiveCountRequest) (*AlertsActiveCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertsActiveCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsActiveCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/active/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsActiveRegionRequest struct {
	ctx context.Context
	ApiService DefaultApi
	region MarineRegionCode
}

func (r ApiAlertsActiveRegionRequest) Execute() (*AlertCollectionGeoJson, *http.Response, error) {
	return r.ApiService.AlertsActiveRegionExecute(r)
}

/*
AlertsActiveRegion Method for AlertsActiveRegion

Returns active alerts for the given marine region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param region Marine region ID
 @return ApiAlertsActiveRegionRequest
*/
func (a *DefaultApiService) AlertsActiveRegion(ctx context.Context, region MarineRegionCode) ApiAlertsActiveRegionRequest {
	return ApiAlertsActiveRegionRequest{
		ApiService: a,
		ctx: ctx,
		region: region,
	}
}

// Execute executes the request
//  @return AlertCollectionGeoJson
func (a *DefaultApiService) AlertsActiveRegionExecute(r ApiAlertsActiveRegionRequest) (*AlertCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsActiveRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/active/region/{region}"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterToString(r.region, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/atom+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsActiveZoneRequest struct {
	ctx context.Context
	ApiService DefaultApi
	zoneId string
}

func (r ApiAlertsActiveZoneRequest) Execute() (*AlertCollectionGeoJson, *http.Response, error) {
	return r.ApiService.AlertsActiveZoneExecute(r)
}

/*
AlertsActiveZone Method for AlertsActiveZone

Returns active alerts for the given NWS public zone or county

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId NWS public zone/county identifier
 @return ApiAlertsActiveZoneRequest
*/
func (a *DefaultApiService) AlertsActiveZone(ctx context.Context, zoneId string) ApiAlertsActiveZoneRequest {
	return ApiAlertsActiveZoneRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return AlertCollectionGeoJson
func (a *DefaultApiService) AlertsActiveZoneExecute(r ApiAlertsActiveZoneRequest) (*AlertCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsActiveZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/active/zone/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(parameterToString(r.zoneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/atom+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsQueryRequest struct {
	ctx context.Context
	ApiService DefaultApi
	active *bool
	start *time.Time
	end *time.Time
	status *[]string
	messageType *[]string
	event *[]string
	code *[]string
	area *[]AreaCode
	point *string
	region *[]MarineRegionCode
	regionType *string
	zone *[]string
	urgency *[]AlertUrgency
	severity *[]AlertSeverity
	certainty *[]AlertCertainty
	limit *int32
	cursor *string
}

// List only active alerts (use /alerts/active endpoints instead)
// Deprecated
func (r ApiAlertsQueryRequest) Active(active bool) ApiAlertsQueryRequest {
	r.active = &active
	return r
}

// Start time
func (r ApiAlertsQueryRequest) Start(start time.Time) ApiAlertsQueryRequest {
	r.start = &start
	return r
}

// End time
func (r ApiAlertsQueryRequest) End(end time.Time) ApiAlertsQueryRequest {
	r.end = &end
	return r
}

// Status (actual, exercise, system, test, draft)
func (r ApiAlertsQueryRequest) Status(status []string) ApiAlertsQueryRequest {
	r.status = &status
	return r
}

// Message type (alert, update, cancel)
func (r ApiAlertsQueryRequest) MessageType(messageType []string) ApiAlertsQueryRequest {
	r.messageType = &messageType
	return r
}

// Event name
func (r ApiAlertsQueryRequest) Event(event []string) ApiAlertsQueryRequest {
	r.event = &event
	return r
}

// Event code
func (r ApiAlertsQueryRequest) Code(code []string) ApiAlertsQueryRequest {
	r.code = &code
	return r
}

// State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
func (r ApiAlertsQueryRequest) Area(area []AreaCode) ApiAlertsQueryRequest {
	r.area = &area
	return r
}

// Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
func (r ApiAlertsQueryRequest) Point(point string) ApiAlertsQueryRequest {
	r.point = &point
	return r
}

// Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
func (r ApiAlertsQueryRequest) Region(region []MarineRegionCode) ApiAlertsQueryRequest {
	r.region = &region
	return r
}

// Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
func (r ApiAlertsQueryRequest) RegionType(regionType string) ApiAlertsQueryRequest {
	r.regionType = &regionType
	return r
}

// Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
func (r ApiAlertsQueryRequest) Zone(zone []string) ApiAlertsQueryRequest {
	r.zone = &zone
	return r
}

// Urgency (immediate, expected, future, past, unknown)
func (r ApiAlertsQueryRequest) Urgency(urgency []AlertUrgency) ApiAlertsQueryRequest {
	r.urgency = &urgency
	return r
}

// Severity (extreme, severe, moderate, minor, unknown)
func (r ApiAlertsQueryRequest) Severity(severity []AlertSeverity) ApiAlertsQueryRequest {
	r.severity = &severity
	return r
}

// Certainty (observed, likely, possible, unlikely, unknown)
func (r ApiAlertsQueryRequest) Certainty(certainty []AlertCertainty) ApiAlertsQueryRequest {
	r.certainty = &certainty
	return r
}

// Limit
func (r ApiAlertsQueryRequest) Limit(limit int32) ApiAlertsQueryRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiAlertsQueryRequest) Cursor(cursor string) ApiAlertsQueryRequest {
	r.cursor = &cursor
	return r
}

func (r ApiAlertsQueryRequest) Execute() (*AlertCollectionGeoJson, *http.Response, error) {
	return r.ApiService.AlertsQueryExecute(r)
}

/*
AlertsQuery Method for AlertsQuery

Returns all alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertsQueryRequest
*/
func (a *DefaultApiService) AlertsQuery(ctx context.Context) ApiAlertsQueryRequest {
	return ApiAlertsQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertCollectionGeoJson
func (a *DefaultApiService) AlertsQueryExecute(r ApiAlertsQueryRequest) (*AlertCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, "csv"))
	}
	if r.messageType != nil {
		localVarQueryParams.Add("message_type", parameterToString(*r.messageType, "csv"))
	}
	if r.event != nil {
		localVarQueryParams.Add("event", parameterToString(*r.event, "csv"))
	}
	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, "csv"))
	}
	if r.area != nil {
		localVarQueryParams.Add("area", parameterToString(*r.area, "csv"))
	}
	if r.point != nil {
		localVarQueryParams.Add("point", parameterToString(*r.point, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, "csv"))
	}
	if r.regionType != nil {
		localVarQueryParams.Add("region_type", parameterToString(*r.regionType, ""))
	}
	if r.zone != nil {
		localVarQueryParams.Add("zone", parameterToString(*r.zone, "csv"))
	}
	if r.urgency != nil {
		localVarQueryParams.Add("urgency", parameterToString(*r.urgency, "csv"))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, "csv"))
	}
	if r.certainty != nil {
		localVarQueryParams.Add("certainty", parameterToString(*r.certainty, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/atom+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsSingleRequest struct {
	ctx context.Context
	ApiService DefaultApi
	id string
}

func (r ApiAlertsSingleRequest) Execute() (*AlertGeoJson, *http.Response, error) {
	return r.ApiService.AlertsSingleExecute(r)
}

/*
AlertsSingle Method for AlertsSingle

Returns a specific alert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Alert identifier
 @return ApiAlertsSingleRequest
*/
func (a *DefaultApiService) AlertsSingle(ctx context.Context, id string) ApiAlertsSingleRequest {
	return ApiAlertsSingleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AlertGeoJson
func (a *DefaultApiService) AlertsSingleExecute(r ApiAlertsSingleRequest) (*AlertGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsSingle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/cap+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsTypesRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiAlertsTypesRequest) Execute() (*AlertsTypes200Response, *http.Response, error) {
	return r.ApiService.AlertsTypesExecute(r)
}

/*
AlertsTypes Method for AlertsTypes

Returns a list of alert types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertsTypesRequest
*/
func (a *DefaultApiService) AlertsTypes(ctx context.Context) ApiAlertsTypesRequest {
	return ApiAlertsTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertsTypes200Response
func (a *DefaultApiService) AlertsTypesExecute(r ApiAlertsTypesRequest) (*AlertsTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertsTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlertsTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGlossaryRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiGlossaryRequest) Execute() (*Glossary200Response, *http.Response, error) {
	return r.ApiService.GlossaryExecute(r)
}

/*
Glossary Method for Glossary

Returns glossary terms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGlossaryRequest
*/
func (a *DefaultApiService) Glossary(ctx context.Context) ApiGlossaryRequest {
	return ApiGlossaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Glossary200Response
func (a *DefaultApiService) GlossaryExecute(r ApiGlossaryRequest) (*Glossary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Glossary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Glossary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/glossary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGridpointRequest struct {
	ctx context.Context
	ApiService DefaultApi
	wfo NWSForecastOfficeId
	x int32
	y int32
}

func (r ApiGridpointRequest) Execute() (*GridpointGeoJson, *http.Response, error) {
	return r.ApiService.GridpointExecute(r)
}

/*
Gridpoint Method for Gridpoint

Returns raw numerical forecast data for a 2.5km grid area

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param wfo Forecast office ID
 @param x Forecast grid X coordinate
 @param y Forecast grid Y coordinate
 @return ApiGridpointRequest
*/
func (a *DefaultApiService) Gridpoint(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointRequest {
	return ApiGridpointRequest{
		ApiService: a,
		ctx: ctx,
		wfo: wfo,
		x: x,
		y: y,
	}
}

// Execute executes the request
//  @return GridpointGeoJson
func (a *DefaultApiService) GridpointExecute(r ApiGridpointRequest) (*GridpointGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GridpointGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Gridpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gridpoints/{wfo}/{x},{y}"
	localVarPath = strings.Replace(localVarPath, "{"+"wfo"+"}", url.PathEscape(parameterToString(r.wfo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"x"+"}", url.PathEscape(parameterToString(r.x, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"y"+"}", url.PathEscape(parameterToString(r.y, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x < 0 {
		return localVarReturnValue, nil, reportError("x must be greater than 0")
	}
	if r.y < 0 {
		return localVarReturnValue, nil, reportError("y must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGridpointForecastRequest struct {
	ctx context.Context
	ApiService DefaultApi
	wfo NWSForecastOfficeId
	x int32
	y int32
	featureFlags *[]string
	units *GridpointForecastUnits
}

// Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
func (r ApiGridpointForecastRequest) FeatureFlags(featureFlags []string) ApiGridpointForecastRequest {
	r.featureFlags = &featureFlags
	return r
}

// Use US customary or SI (metric) units in textual output
func (r ApiGridpointForecastRequest) Units(units GridpointForecastUnits) ApiGridpointForecastRequest {
	r.units = &units
	return r
}

func (r ApiGridpointForecastRequest) Execute() (*GridpointForecastGeoJson, *http.Response, error) {
	return r.ApiService.GridpointForecastExecute(r)
}

/*
GridpointForecast Method for GridpointForecast

Returns a textual forecast for a 2.5km grid area

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param wfo Forecast office ID
 @param x Forecast grid X coordinate
 @param y Forecast grid Y coordinate
 @return ApiGridpointForecastRequest
*/
func (a *DefaultApiService) GridpointForecast(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointForecastRequest {
	return ApiGridpointForecastRequest{
		ApiService: a,
		ctx: ctx,
		wfo: wfo,
		x: x,
		y: y,
	}
}

// Execute executes the request
//  @return GridpointForecastGeoJson
func (a *DefaultApiService) GridpointForecastExecute(r ApiGridpointForecastRequest) (*GridpointForecastGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GridpointForecastGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GridpointForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gridpoints/{wfo}/{x},{y}/forecast"
	localVarPath = strings.Replace(localVarPath, "{"+"wfo"+"}", url.PathEscape(parameterToString(r.wfo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"x"+"}", url.PathEscape(parameterToString(r.x, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"y"+"}", url.PathEscape(parameterToString(r.y, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x < 0 {
		return localVarReturnValue, nil, reportError("x must be greater than 0")
	}
	if r.y < 0 {
		return localVarReturnValue, nil, reportError("y must be greater than 0")
	}

	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/vnd.noaa.dwml+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.featureFlags != nil {
		localVarHeaderParams["Feature-Flags"] = parameterToString(*r.featureFlags, "csv")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGridpointForecastHourlyRequest struct {
	ctx context.Context
	ApiService DefaultApi
	wfo NWSForecastOfficeId
	x int32
	y int32
	featureFlags *[]string
	units *GridpointForecastUnits
}

// Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
func (r ApiGridpointForecastHourlyRequest) FeatureFlags(featureFlags []string) ApiGridpointForecastHourlyRequest {
	r.featureFlags = &featureFlags
	return r
}

// Use US customary or SI (metric) units in textual output
func (r ApiGridpointForecastHourlyRequest) Units(units GridpointForecastUnits) ApiGridpointForecastHourlyRequest {
	r.units = &units
	return r
}

func (r ApiGridpointForecastHourlyRequest) Execute() (*GridpointForecastGeoJson, *http.Response, error) {
	return r.ApiService.GridpointForecastHourlyExecute(r)
}

/*
GridpointForecastHourly Method for GridpointForecastHourly

Returns a textual hourly forecast for a 2.5km grid area

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param wfo Forecast office ID
 @param x Forecast grid X coordinate
 @param y Forecast grid Y coordinate
 @return ApiGridpointForecastHourlyRequest
*/
func (a *DefaultApiService) GridpointForecastHourly(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointForecastHourlyRequest {
	return ApiGridpointForecastHourlyRequest{
		ApiService: a,
		ctx: ctx,
		wfo: wfo,
		x: x,
		y: y,
	}
}

// Execute executes the request
//  @return GridpointForecastGeoJson
func (a *DefaultApiService) GridpointForecastHourlyExecute(r ApiGridpointForecastHourlyRequest) (*GridpointForecastGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GridpointForecastGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GridpointForecastHourly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gridpoints/{wfo}/{x},{y}/forecast/hourly"
	localVarPath = strings.Replace(localVarPath, "{"+"wfo"+"}", url.PathEscape(parameterToString(r.wfo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"x"+"}", url.PathEscape(parameterToString(r.x, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"y"+"}", url.PathEscape(parameterToString(r.y, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x < 0 {
		return localVarReturnValue, nil, reportError("x must be greater than 0")
	}
	if r.y < 0 {
		return localVarReturnValue, nil, reportError("y must be greater than 0")
	}

	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/vnd.noaa.dwml+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.featureFlags != nil {
		localVarHeaderParams["Feature-Flags"] = parameterToString(*r.featureFlags, "csv")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGridpointStationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	wfo NWSForecastOfficeId
	x int32
	y int32
}

func (r ApiGridpointStationsRequest) Execute() (*ObservationStationCollectionGeoJson, *http.Response, error) {
	return r.ApiService.GridpointStationsExecute(r)
}

/*
GridpointStations Method for GridpointStations

Returns a list of observation stations usable for a given 2.5km grid area

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param wfo Forecast office ID
 @param x Forecast grid X coordinate
 @param y Forecast grid Y coordinate
 @return ApiGridpointStationsRequest
*/
func (a *DefaultApiService) GridpointStations(ctx context.Context, wfo NWSForecastOfficeId, x int32, y int32) ApiGridpointStationsRequest {
	return ApiGridpointStationsRequest{
		ApiService: a,
		ctx: ctx,
		wfo: wfo,
		x: x,
		y: y,
	}
}

// Execute executes the request
//  @return ObservationStationCollectionGeoJson
func (a *DefaultApiService) GridpointStationsExecute(r ApiGridpointStationsRequest) (*ObservationStationCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationStationCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GridpointStations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gridpoints/{wfo}/{x},{y}/stations"
	localVarPath = strings.Replace(localVarPath, "{"+"wfo"+"}", url.PathEscape(parameterToString(r.wfo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"x"+"}", url.PathEscape(parameterToString(r.x, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"y"+"}", url.PathEscape(parameterToString(r.y, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x < 0 {
		return localVarReturnValue, nil, reportError("x must be greater than 0")
	}
	if r.y < 0 {
		return localVarReturnValue, nil, reportError("y must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIconsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	set string
	timeOfDay string
	first string
	size *IconsSizeParameter
	fontsize *int32
}

// Font size
func (r ApiIconsRequest) Size(size IconsSizeParameter) ApiIconsRequest {
	r.size = &size
	return r
}

// Font size
func (r ApiIconsRequest) Fontsize(fontsize int32) ApiIconsRequest {
	r.fontsize = &fontsize
	return r
}

func (r ApiIconsRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.IconsExecute(r)
}

/*
Icons Method for Icons

Returns a forecast icon. Icon services in API are deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param set .
 @param timeOfDay .
 @param first .
 @return ApiIconsRequest

Deprecated
*/
func (a *DefaultApiService) Icons(ctx context.Context, set string, timeOfDay string, first string) ApiIconsRequest {
	return ApiIconsRequest{
		ApiService: a,
		ctx: ctx,
		set: set,
		timeOfDay: timeOfDay,
		first: first,
	}
}

// Execute executes the request
//  @return *os.File
// Deprecated
func (a *DefaultApiService) IconsExecute(r ApiIconsRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Icons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons/{set}/{timeOfDay}/{first}"
	localVarPath = strings.Replace(localVarPath, "{"+"set"+"}", url.PathEscape(parameterToString(r.set, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOfDay"+"}", url.PathEscape(parameterToString(r.timeOfDay, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"first"+"}", url.PathEscape(parameterToString(r.first, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.fontsize != nil {
		localVarQueryParams.Add("fontsize", parameterToString(*r.fontsize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIconsDualConditionRequest struct {
	ctx context.Context
	ApiService DefaultApi
	set string
	timeOfDay string
	first string
	second string
	size *IconsSizeParameter
	fontsize *int32
}

// Font size
func (r ApiIconsDualConditionRequest) Size(size IconsSizeParameter) ApiIconsDualConditionRequest {
	r.size = &size
	return r
}

// Font size
func (r ApiIconsDualConditionRequest) Fontsize(fontsize int32) ApiIconsDualConditionRequest {
	r.fontsize = &fontsize
	return r
}

func (r ApiIconsDualConditionRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.IconsDualConditionExecute(r)
}

/*
IconsDualCondition Method for IconsDualCondition

Returns a forecast icon. Icon services in API are deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param set .
 @param timeOfDay .
 @param first .
 @param second .
 @return ApiIconsDualConditionRequest

Deprecated
*/
func (a *DefaultApiService) IconsDualCondition(ctx context.Context, set string, timeOfDay string, first string, second string) ApiIconsDualConditionRequest {
	return ApiIconsDualConditionRequest{
		ApiService: a,
		ctx: ctx,
		set: set,
		timeOfDay: timeOfDay,
		first: first,
		second: second,
	}
}

// Execute executes the request
//  @return *os.File
// Deprecated
func (a *DefaultApiService) IconsDualConditionExecute(r ApiIconsDualConditionRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.IconsDualCondition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons/{set}/{timeOfDay}/{first}/{second}"
	localVarPath = strings.Replace(localVarPath, "{"+"set"+"}", url.PathEscape(parameterToString(r.set, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timeOfDay"+"}", url.PathEscape(parameterToString(r.timeOfDay, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"first"+"}", url.PathEscape(parameterToString(r.first, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"second"+"}", url.PathEscape(parameterToString(r.second, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.fontsize != nil {
		localVarQueryParams.Add("fontsize", parameterToString(*r.fontsize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIconsSummaryRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiIconsSummaryRequest) Execute() (*IconsSummary200Response, *http.Response, error) {
	return r.ApiService.IconsSummaryExecute(r)
}

/*
IconsSummary Method for IconsSummary

Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIconsSummaryRequest

Deprecated
*/
func (a *DefaultApiService) IconsSummary(ctx context.Context) ApiIconsSummaryRequest {
	return ApiIconsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IconsSummary200Response
// Deprecated
func (a *DefaultApiService) IconsSummaryExecute(r ApiIconsSummaryRequest) (*IconsSummary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IconsSummary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.IconsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocationProductsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	locationId string
}

func (r ApiLocationProductsRequest) Execute() (*TextProductTypeCollection, *http.Response, error) {
	return r.ApiService.LocationProductsExecute(r)
}

/*
LocationProducts Method for LocationProducts

Returns a list of valid text product types for a given issuance location

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locationId .
 @return ApiLocationProductsRequest
*/
func (a *DefaultApiService) LocationProducts(ctx context.Context, locationId string) ApiLocationProductsRequest {
	return ApiLocationProductsRequest{
		ApiService: a,
		ctx: ctx,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return TextProductTypeCollection
func (a *DefaultApiService) LocationProductsExecute(r ApiLocationProductsRequest) (*TextProductTypeCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductTypeCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LocationProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/locations/{locationId}/types"
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiObsStationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
}

func (r ApiObsStationRequest) Execute() (*ObservationStationGeoJson, *http.Response, error) {
	return r.ApiService.ObsStationExecute(r)
}

/*
ObsStation Method for ObsStation

Returns metadata about a given observation station

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Observation station ID
 @return ApiObsStationRequest
*/
func (a *DefaultApiService) ObsStation(ctx context.Context, stationId string) ApiObsStationRequest {
	return ApiObsStationRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
//  @return ObservationStationGeoJson
func (a *DefaultApiService) ObsStationExecute(r ApiObsStationRequest) (*ObservationStationGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationStationGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ObsStation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stations/{stationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiObsStationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	id *[]string
	state *[]AreaCode
	limit *int32
}

// Filter by observation station ID
func (r ApiObsStationsRequest) Id(id []string) ApiObsStationsRequest {
	r.id = &id
	return r
}

// Filter by state/marine area code
func (r ApiObsStationsRequest) State(state []AreaCode) ApiObsStationsRequest {
	r.state = &state
	return r
}

// Limit
func (r ApiObsStationsRequest) Limit(limit int32) ApiObsStationsRequest {
	r.limit = &limit
	return r
}

func (r ApiObsStationsRequest) Execute() (*ObservationStationCollectionGeoJson, *http.Response, error) {
	return r.ApiService.ObsStationsExecute(r)
}

/*
ObsStations Method for ObsStations

Returns a list of observation stations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObsStationsRequest
*/
func (a *DefaultApiService) ObsStations(ctx context.Context) ApiObsStationsRequest {
	return ApiObsStationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObservationStationCollectionGeoJson
func (a *DefaultApiService) ObsStationsExecute(r ApiObsStationsRequest) (*ObservationStationCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationStationCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ObsStations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOfficeRequest struct {
	ctx context.Context
	ApiService DefaultApi
	officeId NWSForecastOfficeId
}

func (r ApiOfficeRequest) Execute() (*Office, *http.Response, error) {
	return r.ApiService.OfficeExecute(r)
}

/*
Office Method for Office

Returns metadata about a NWS forecast office

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param officeId NWS forecast office ID
 @return ApiOfficeRequest
*/
func (a *DefaultApiService) Office(ctx context.Context, officeId NWSForecastOfficeId) ApiOfficeRequest {
	return ApiOfficeRequest{
		ApiService: a,
		ctx: ctx,
		officeId: officeId,
	}
}

// Execute executes the request
//  @return Office
func (a *DefaultApiService) OfficeExecute(r ApiOfficeRequest) (*Office, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Office
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Office")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/offices/{officeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"officeId"+"}", url.PathEscape(parameterToString(r.officeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOfficeHeadlineRequest struct {
	ctx context.Context
	ApiService DefaultApi
	officeId NWSForecastOfficeId
	headlineId string
}

func (r ApiOfficeHeadlineRequest) Execute() (*OfficeHeadline, *http.Response, error) {
	return r.ApiService.OfficeHeadlineExecute(r)
}

/*
OfficeHeadline Method for OfficeHeadline

Returns a specific news headline for a given NWS office

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param officeId NWS forecast office ID
 @param headlineId Headline record ID
 @return ApiOfficeHeadlineRequest
*/
func (a *DefaultApiService) OfficeHeadline(ctx context.Context, officeId NWSForecastOfficeId, headlineId string) ApiOfficeHeadlineRequest {
	return ApiOfficeHeadlineRequest{
		ApiService: a,
		ctx: ctx,
		officeId: officeId,
		headlineId: headlineId,
	}
}

// Execute executes the request
//  @return OfficeHeadline
func (a *DefaultApiService) OfficeHeadlineExecute(r ApiOfficeHeadlineRequest) (*OfficeHeadline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfficeHeadline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OfficeHeadline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/offices/{officeId}/headlines/{headlineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"officeId"+"}", url.PathEscape(parameterToString(r.officeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"headlineId"+"}", url.PathEscape(parameterToString(r.headlineId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOfficeHeadlinesRequest struct {
	ctx context.Context
	ApiService DefaultApi
	officeId NWSForecastOfficeId
}

func (r ApiOfficeHeadlinesRequest) Execute() (*OfficeHeadlineCollection, *http.Response, error) {
	return r.ApiService.OfficeHeadlinesExecute(r)
}

/*
OfficeHeadlines Method for OfficeHeadlines

Returns a list of news headlines for a given NWS office

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param officeId NWS forecast office ID
 @return ApiOfficeHeadlinesRequest
*/
func (a *DefaultApiService) OfficeHeadlines(ctx context.Context, officeId NWSForecastOfficeId) ApiOfficeHeadlinesRequest {
	return ApiOfficeHeadlinesRequest{
		ApiService: a,
		ctx: ctx,
		officeId: officeId,
	}
}

// Execute executes the request
//  @return OfficeHeadlineCollection
func (a *DefaultApiService) OfficeHeadlinesExecute(r ApiOfficeHeadlinesRequest) (*OfficeHeadlineCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfficeHeadlineCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OfficeHeadlines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/offices/{officeId}/headlines"
	localVarPath = strings.Replace(localVarPath, "{"+"officeId"+"}", url.PathEscape(parameterToString(r.officeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPointRequest struct {
	ctx context.Context
	ApiService DefaultApi
	point string
}

func (r ApiPointRequest) Execute() (*PointGeoJson, *http.Response, error) {
	return r.ApiService.PointExecute(r)
}

/*
Point Method for Point

Returns metadata about a given latitude/longitude point

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param point Point (latitude, longitude)
 @return ApiPointRequest
*/
func (a *DefaultApiService) Point(ctx context.Context, point string) ApiPointRequest {
	return ApiPointRequest{
		ApiService: a,
		ctx: ctx,
		point: point,
	}
}

// Execute executes the request
//  @return PointGeoJson
func (a *DefaultApiService) PointExecute(r ApiPointRequest) (*PointGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PointGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Point")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/points/{point}"
	localVarPath = strings.Replace(localVarPath, "{"+"point"+"}", url.PathEscape(parameterToString(r.point, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPointStationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	point string
}

func (r ApiPointStationsRequest) Execute() (*ProblemDetail, *http.Response, error) {
	return r.ApiService.PointStationsExecute(r)
}

/*
PointStations Method for PointStations

Returns a list of observation stations for a given point

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param point Point (latitude, longitude)
 @return ApiPointStationsRequest

Deprecated
*/
func (a *DefaultApiService) PointStations(ctx context.Context, point string) ApiPointStationsRequest {
	return ApiPointStationsRequest{
		ApiService: a,
		ctx: ctx,
		point: point,
	}
}

// Execute executes the request
//  @return ProblemDetail
// Deprecated
func (a *DefaultApiService) PointStationsExecute(r ApiPointStationsRequest) (*ProblemDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProblemDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PointStations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/points/{point}/stations"
	localVarPath = strings.Replace(localVarPath, "{"+"point"+"}", url.PathEscape(parameterToString(r.point, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductRequest struct {
	ctx context.Context
	ApiService DefaultApi
	productId string
}

func (r ApiProductRequest) Execute() (*TextProduct, *http.Response, error) {
	return r.ApiService.ProductExecute(r)
}

/*
Product Method for Product

Returns a specific text product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param productId .
 @return ApiProductRequest
*/
func (a *DefaultApiService) Product(ctx context.Context, productId string) ApiProductRequest {
	return ApiProductRequest{
		ApiService: a,
		ctx: ctx,
		productId: productId,
	}
}

// Execute executes the request
//  @return TextProduct
func (a *DefaultApiService) ProductExecute(r ApiProductRequest) (*TextProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Product")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/{productId}"
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductLocationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiProductLocationsRequest) Execute() (*TextProductLocationCollection, *http.Response, error) {
	return r.ApiService.ProductLocationsExecute(r)
}

/*
ProductLocations Method for ProductLocations

Returns a list of valid text product issuance locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductLocationsRequest
*/
func (a *DefaultApiService) ProductLocations(ctx context.Context) ApiProductLocationsRequest {
	return ApiProductLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TextProductLocationCollection
func (a *DefaultApiService) ProductLocationsExecute(r ApiProductLocationsRequest) (*TextProductLocationCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductLocationCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ProductLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/locations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductTypesRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiProductTypesRequest) Execute() (*TextProductTypeCollection, *http.Response, error) {
	return r.ApiService.ProductTypesExecute(r)
}

/*
ProductTypes Method for ProductTypes

Returns a list of valid text product types and codes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductTypesRequest
*/
func (a *DefaultApiService) ProductTypes(ctx context.Context) ApiProductTypesRequest {
	return ApiProductTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TextProductTypeCollection
func (a *DefaultApiService) ProductTypesExecute(r ApiProductTypesRequest) (*TextProductTypeCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductTypeCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ProductTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsQueryRequest struct {
	ctx context.Context
	ApiService DefaultApi
	location *[]string
	start *time.Time
	end *time.Time
	office *[]string
	wmoid *[]string
	type_ *[]string
	limit *int32
}

// Location id
func (r ApiProductsQueryRequest) Location(location []string) ApiProductsQueryRequest {
	r.location = &location
	return r
}

// Start time
func (r ApiProductsQueryRequest) Start(start time.Time) ApiProductsQueryRequest {
	r.start = &start
	return r
}

// End time
func (r ApiProductsQueryRequest) End(end time.Time) ApiProductsQueryRequest {
	r.end = &end
	return r
}

// Issuing office
func (r ApiProductsQueryRequest) Office(office []string) ApiProductsQueryRequest {
	r.office = &office
	return r
}

// WMO id code
func (r ApiProductsQueryRequest) Wmoid(wmoid []string) ApiProductsQueryRequest {
	r.wmoid = &wmoid
	return r
}

// Product code
func (r ApiProductsQueryRequest) Type_(type_ []string) ApiProductsQueryRequest {
	r.type_ = &type_
	return r
}

// Limit
func (r ApiProductsQueryRequest) Limit(limit int32) ApiProductsQueryRequest {
	r.limit = &limit
	return r
}

func (r ApiProductsQueryRequest) Execute() (*TextProductCollection, *http.Response, error) {
	return r.ApiService.ProductsQueryExecute(r)
}

/*
ProductsQuery Method for ProductsQuery

Returns a list of text products

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductsQueryRequest
*/
func (a *DefaultApiService) ProductsQuery(ctx context.Context) ApiProductsQueryRequest {
	return ApiProductsQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TextProductCollection
func (a *DefaultApiService) ProductsQueryExecute(r ApiProductsQueryRequest) (*TextProductCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ProductsQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.location != nil {
		localVarQueryParams.Add("location", parameterToString(*r.location, "csv"))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.office != nil {
		localVarQueryParams.Add("office", parameterToString(*r.office, "csv"))
	}
	if r.wmoid != nil {
		localVarQueryParams.Add("wmoid", parameterToString(*r.wmoid, "csv"))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsTypeRequest struct {
	ctx context.Context
	ApiService DefaultApi
	typeId string
}

func (r ApiProductsTypeRequest) Execute() (*TextProductCollection, *http.Response, error) {
	return r.ApiService.ProductsTypeExecute(r)
}

/*
ProductsType Method for ProductsType

Returns a list of text products of a given type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeId .
 @return ApiProductsTypeRequest
*/
func (a *DefaultApiService) ProductsType(ctx context.Context, typeId string) ApiProductsTypeRequest {
	return ApiProductsTypeRequest{
		ApiService: a,
		ctx: ctx,
		typeId: typeId,
	}
}

// Execute executes the request
//  @return TextProductCollection
func (a *DefaultApiService) ProductsTypeExecute(r ApiProductsTypeRequest) (*TextProductCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ProductsType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/types/{typeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterToString(r.typeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsTypeLocationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	typeId string
	locationId string
}

func (r ApiProductsTypeLocationRequest) Execute() (*TextProductCollection, *http.Response, error) {
	return r.ApiService.ProductsTypeLocationExecute(r)
}

/*
ProductsTypeLocation Method for ProductsTypeLocation

Returns a list of text products of a given type for a given issuance location

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeId .
 @param locationId .
 @return ApiProductsTypeLocationRequest
*/
func (a *DefaultApiService) ProductsTypeLocation(ctx context.Context, typeId string, locationId string) ApiProductsTypeLocationRequest {
	return ApiProductsTypeLocationRequest{
		ApiService: a,
		ctx: ctx,
		typeId: typeId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return TextProductCollection
func (a *DefaultApiService) ProductsTypeLocationExecute(r ApiProductsTypeLocationRequest) (*TextProductCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ProductsTypeLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/types/{typeId}/locations/{locationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterToString(r.typeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsTypeLocationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	typeId string
}

func (r ApiProductsTypeLocationsRequest) Execute() (*TextProductLocationCollection, *http.Response, error) {
	return r.ApiService.ProductsTypeLocationsExecute(r)
}

/*
ProductsTypeLocations Method for ProductsTypeLocations

Returns a list of valid text product issuance locations for a given product type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeId .
 @return ApiProductsTypeLocationsRequest
*/
func (a *DefaultApiService) ProductsTypeLocations(ctx context.Context, typeId string) ApiProductsTypeLocationsRequest {
	return ApiProductsTypeLocationsRequest{
		ApiService: a,
		ctx: ctx,
		typeId: typeId,
	}
}

// Execute executes the request
//  @return TextProductLocationCollection
func (a *DefaultApiService) ProductsTypeLocationsExecute(r ApiProductsTypeLocationsRequest) (*TextProductLocationCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextProductLocationCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ProductsTypeLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products/types/{typeId}/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterToString(r.typeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRadarProfilerRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
	time *ISO8601Interval
	interval *string
}

// Time interval
func (r ApiRadarProfilerRequest) Time(time ISO8601Interval) ApiRadarProfilerRequest {
	r.time = &time
	return r
}

// Averaging interval
func (r ApiRadarProfilerRequest) Interval(interval string) ApiRadarProfilerRequest {
	r.interval = &interval
	return r
}

func (r ApiRadarProfilerRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarProfilerExecute(r)
}

/*
RadarProfiler Method for RadarProfiler

Returns metadata about a given radar wind profiler

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Profiler station ID
 @return ApiRadarProfilerRequest
*/
func (a *DefaultApiService) RadarProfiler(ctx context.Context, stationId string) ApiRadarProfilerRequest {
	return ApiRadarProfilerRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarProfilerExecute(r ApiRadarProfilerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarProfiler")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/profilers/{stationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.time != nil {
		localVarQueryParams.Add("time", parameterToString(*r.time, ""))
	}
	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRadarQueueRequest struct {
	ctx context.Context
	ApiService DefaultApi
	host string
	limit *int32
	arrived *ISO8601Interval
	created *ISO8601Interval
	published *ISO8601Interval
	station *string
	type_ *string
	feed *string
	resolution *int32
}

// Record limit
func (r ApiRadarQueueRequest) Limit(limit int32) ApiRadarQueueRequest {
	r.limit = &limit
	return r
}

// Range for arrival time
func (r ApiRadarQueueRequest) Arrived(arrived ISO8601Interval) ApiRadarQueueRequest {
	r.arrived = &arrived
	return r
}

// Range for creation time
func (r ApiRadarQueueRequest) Created(created ISO8601Interval) ApiRadarQueueRequest {
	r.created = &created
	return r
}

// Range for publish time
func (r ApiRadarQueueRequest) Published(published ISO8601Interval) ApiRadarQueueRequest {
	r.published = &published
	return r
}

// Station identifier
func (r ApiRadarQueueRequest) Station(station string) ApiRadarQueueRequest {
	r.station = &station
	return r
}

// Record type
func (r ApiRadarQueueRequest) Type_(type_ string) ApiRadarQueueRequest {
	r.type_ = &type_
	return r
}

// Originating product feed
func (r ApiRadarQueueRequest) Feed(feed string) ApiRadarQueueRequest {
	r.feed = &feed
	return r
}

// Resolution version
func (r ApiRadarQueueRequest) Resolution(resolution int32) ApiRadarQueueRequest {
	r.resolution = &resolution
	return r
}

func (r ApiRadarQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarQueueExecute(r)
}

/*
RadarQueue Method for RadarQueue

Returns metadata about a given radar queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param host LDM host
 @return ApiRadarQueueRequest
*/
func (a *DefaultApiService) RadarQueue(ctx context.Context, host string) ApiRadarQueueRequest {
	return ApiRadarQueueRequest{
		ApiService: a,
		ctx: ctx,
		host: host,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarQueueExecute(r ApiRadarQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/queues/{host}"
	localVarPath = strings.Replace(localVarPath, "{"+"host"+"}", url.PathEscape(parameterToString(r.host, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.arrived != nil {
		localVarQueryParams.Add("arrived", parameterToString(*r.arrived, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.published != nil {
		localVarQueryParams.Add("published", parameterToString(*r.published, ""))
	}
	if r.station != nil {
		localVarQueryParams.Add("station", parameterToString(*r.station, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.feed != nil {
		localVarQueryParams.Add("feed", parameterToString(*r.feed, ""))
	}
	if r.resolution != nil {
		localVarQueryParams.Add("resolution", parameterToString(*r.resolution, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRadarServerRequest struct {
	ctx context.Context
	ApiService DefaultApi
	id string
	reportingHost *string
}

// Show records from specific reporting host
func (r ApiRadarServerRequest) ReportingHost(reportingHost string) ApiRadarServerRequest {
	r.reportingHost = &reportingHost
	return r
}

func (r ApiRadarServerRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarServerExecute(r)
}

/*
RadarServer Method for RadarServer

Returns metadata about a given radar server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Server ID
 @return ApiRadarServerRequest
*/
func (a *DefaultApiService) RadarServer(ctx context.Context, id string) ApiRadarServerRequest {
	return ApiRadarServerRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarServerExecute(r ApiRadarServerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarServer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/servers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reportingHost != nil {
		localVarQueryParams.Add("reportingHost", parameterToString(*r.reportingHost, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRadarServersRequest struct {
	ctx context.Context
	ApiService DefaultApi
	reportingHost *string
}

// Show records from specific reporting host
func (r ApiRadarServersRequest) ReportingHost(reportingHost string) ApiRadarServersRequest {
	r.reportingHost = &reportingHost
	return r
}

func (r ApiRadarServersRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarServersExecute(r)
}

/*
RadarServers Method for RadarServers

Returns a list of radar servers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRadarServersRequest
*/
func (a *DefaultApiService) RadarServers(ctx context.Context) ApiRadarServersRequest {
	return ApiRadarServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarServersExecute(r ApiRadarServersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarServers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reportingHost != nil {
		localVarQueryParams.Add("reportingHost", parameterToString(*r.reportingHost, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRadarStationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
	reportingHost *string
	host *string
}

// Show RDA and latency info from specific reporting host
func (r ApiRadarStationRequest) ReportingHost(reportingHost string) ApiRadarStationRequest {
	r.reportingHost = &reportingHost
	return r
}

// Show latency info from specific LDM host
func (r ApiRadarStationRequest) Host(host string) ApiRadarStationRequest {
	r.host = &host
	return r
}

func (r ApiRadarStationRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarStationExecute(r)
}

/*
RadarStation Method for RadarStation

Returns metadata about a given radar station

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Radar station ID
 @return ApiRadarStationRequest
*/
func (a *DefaultApiService) RadarStation(ctx context.Context, stationId string) ApiRadarStationRequest {
	return ApiRadarStationRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarStationExecute(r ApiRadarStationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarStation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/stations/{stationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reportingHost != nil {
		localVarQueryParams.Add("reportingHost", parameterToString(*r.reportingHost, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRadarStationAlarmsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
}

func (r ApiRadarStationAlarmsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarStationAlarmsExecute(r)
}

/*
RadarStationAlarms Method for RadarStationAlarms

Returns metadata about a given radar station alarms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Radar station ID
 @return ApiRadarStationAlarmsRequest
*/
func (a *DefaultApiService) RadarStationAlarms(ctx context.Context, stationId string) ApiRadarStationAlarmsRequest {
	return ApiRadarStationAlarmsRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarStationAlarmsExecute(r ApiRadarStationAlarmsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarStationAlarms")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/stations/{stationId}/alarms"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRadarStationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationType *[]string
	reportingHost *string
	host *string
}

// Limit results to a specific station type or types
func (r ApiRadarStationsRequest) StationType(stationType []string) ApiRadarStationsRequest {
	r.stationType = &stationType
	return r
}

// Show RDA and latency info from specific reporting host
func (r ApiRadarStationsRequest) ReportingHost(reportingHost string) ApiRadarStationsRequest {
	r.reportingHost = &reportingHost
	return r
}

// Show latency info from specific LDM host
func (r ApiRadarStationsRequest) Host(host string) ApiRadarStationsRequest {
	r.host = &host
	return r
}

func (r ApiRadarStationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RadarStationsExecute(r)
}

/*
RadarStations Method for RadarStations

Returns a list of radar stations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRadarStationsRequest
*/
func (a *DefaultApiService) RadarStations(ctx context.Context) ApiRadarStationsRequest {
	return ApiRadarStationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) RadarStationsExecute(r ApiRadarStationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RadarStations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/radar/stations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stationType != nil {
		localVarQueryParams.Add("stationType", parameterToString(*r.stationType, "csv"))
	}
	if r.reportingHost != nil {
		localVarQueryParams.Add("reportingHost", parameterToString(*r.reportingHost, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSatelliteThumbnailsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	area string
}

func (r ApiSatelliteThumbnailsRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.SatelliteThumbnailsExecute(r)
}

/*
SatelliteThumbnails Method for SatelliteThumbnails

Returns a thumbnail image for a satellite region. Image services in API are deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param area .
 @return ApiSatelliteThumbnailsRequest

Deprecated
*/
func (a *DefaultApiService) SatelliteThumbnails(ctx context.Context, area string) ApiSatelliteThumbnailsRequest {
	return ApiSatelliteThumbnailsRequest{
		ApiService: a,
		ctx: ctx,
		area: area,
	}
}

// Execute executes the request
//  @return *os.File
// Deprecated
func (a *DefaultApiService) SatelliteThumbnailsExecute(r ApiSatelliteThumbnailsRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SatelliteThumbnails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/thumbnails/satellite/{area}"
	localVarPath = strings.Replace(localVarPath, "{"+"area"+"}", url.PathEscape(parameterToString(r.area, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/jpeg", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStationObservationLatestRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
	requireQc *bool
}

// Require QC
func (r ApiStationObservationLatestRequest) RequireQc(requireQc bool) ApiStationObservationLatestRequest {
	r.requireQc = &requireQc
	return r
}

func (r ApiStationObservationLatestRequest) Execute() (*ObservationGeoJson, *http.Response, error) {
	return r.ApiService.StationObservationLatestExecute(r)
}

/*
StationObservationLatest Method for StationObservationLatest

Returns the latest observation for a station

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Observation station ID
 @return ApiStationObservationLatestRequest
*/
func (a *DefaultApiService) StationObservationLatest(ctx context.Context, stationId string) ApiStationObservationLatestRequest {
	return ApiStationObservationLatestRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
//  @return ObservationGeoJson
func (a *DefaultApiService) StationObservationLatestExecute(r ApiStationObservationLatestRequest) (*ObservationGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.StationObservationLatest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stations/{stationId}/observations/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.requireQc != nil {
		localVarQueryParams.Add("require_qc", parameterToString(*r.requireQc, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/vnd.noaa.obs+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStationObservationListRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
	start *time.Time
	end *time.Time
	limit *int32
}

// Start time
func (r ApiStationObservationListRequest) Start(start time.Time) ApiStationObservationListRequest {
	r.start = &start
	return r
}

// End time
func (r ApiStationObservationListRequest) End(end time.Time) ApiStationObservationListRequest {
	r.end = &end
	return r
}

// Limit
func (r ApiStationObservationListRequest) Limit(limit int32) ApiStationObservationListRequest {
	r.limit = &limit
	return r
}

func (r ApiStationObservationListRequest) Execute() (*ObservationCollectionGeoJson, *http.Response, error) {
	return r.ApiService.StationObservationListExecute(r)
}

/*
StationObservationList Method for StationObservationList

Returns a list of observations for a given station

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Observation station ID
 @return ApiStationObservationListRequest
*/
func (a *DefaultApiService) StationObservationList(ctx context.Context, stationId string) ApiStationObservationListRequest {
	return ApiStationObservationListRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
//  @return ObservationCollectionGeoJson
func (a *DefaultApiService) StationObservationListExecute(r ApiStationObservationListRequest) (*ObservationCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.StationObservationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stations/{stationId}/observations"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStationObservationTimeRequest struct {
	ctx context.Context
	ApiService DefaultApi
	stationId string
	time time.Time
}

func (r ApiStationObservationTimeRequest) Execute() (*ObservationGeoJson, *http.Response, error) {
	return r.ApiService.StationObservationTimeExecute(r)
}

/*
StationObservationTime Method for StationObservationTime

Returns a single observation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId Observation station ID
 @param time Timestamp of requested observation
 @return ApiStationObservationTimeRequest
*/
func (a *DefaultApiService) StationObservationTime(ctx context.Context, stationId string, time time.Time) ApiStationObservationTimeRequest {
	return ApiStationObservationTimeRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
		time: time,
	}
}

// Execute executes the request
//  @return ObservationGeoJson
func (a *DefaultApiService) StationObservationTimeExecute(r ApiStationObservationTimeRequest) (*ObservationGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.StationObservationTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stations/{stationId}/observations/{time}"
	localVarPath = strings.Replace(localVarPath, "{"+"stationId"+"}", url.PathEscape(parameterToString(r.stationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"time"+"}", url.PathEscape(parameterToString(r.time, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/vnd.noaa.obs+xml", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoneRequest struct {
	ctx context.Context
	ApiService DefaultApi
	type_ string
	zoneId string
	effective *time.Time
}

// Effective date/time
func (r ApiZoneRequest) Effective(effective time.Time) ApiZoneRequest {
	r.effective = &effective
	return r
}

func (r ApiZoneRequest) Execute() (*ZoneGeoJson, *http.Response, error) {
	return r.ApiService.ZoneExecute(r)
}

/*
Zone Method for Zone

Returns metadata about a given zone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Zone type
 @param zoneId NWS public zone/county identifier
 @return ApiZoneRequest
*/
func (a *DefaultApiService) Zone(ctx context.Context, type_ string, zoneId string) ApiZoneRequest {
	return ApiZoneRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return ZoneGeoJson
func (a *DefaultApiService) ZoneExecute(r ApiZoneRequest) (*ZoneGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Zone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/{type}/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterToString(r.type_, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(parameterToString(r.zoneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.effective != nil {
		localVarQueryParams.Add("effective", parameterToString(*r.effective, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoneForecastRequest struct {
	ctx context.Context
	ApiService DefaultApi
	type_ string
	zoneId string
}

func (r ApiZoneForecastRequest) Execute() (*ZoneForecastGeoJson, *http.Response, error) {
	return r.ApiService.ZoneForecastExecute(r)
}

/*
ZoneForecast Method for ZoneForecast

Returns the current zone forecast for a given zone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Zone type
 @param zoneId NWS public zone/county identifier
 @return ApiZoneForecastRequest
*/
func (a *DefaultApiService) ZoneForecast(ctx context.Context, type_ string, zoneId string) ApiZoneForecastRequest {
	return ApiZoneForecastRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return ZoneForecastGeoJson
func (a *DefaultApiService) ZoneForecastExecute(r ApiZoneForecastRequest) (*ZoneForecastGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneForecastGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ZoneForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/{type}/{zoneId}/forecast"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterToString(r.type_, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(parameterToString(r.zoneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoneListRequest struct {
	ctx context.Context
	ApiService DefaultApi
	id *[]string
	area *[]AreaCode
	region *[]RegionCode
	type_ *[]string
	point *string
	includeGeometry *bool
	limit *int32
	effective *time.Time
}

// Zone ID (forecast or county)
func (r ApiZoneListRequest) Id(id []string) ApiZoneListRequest {
	r.id = &id
	return r
}

// State/marine area code
func (r ApiZoneListRequest) Area(area []AreaCode) ApiZoneListRequest {
	r.area = &area
	return r
}

// Region code
func (r ApiZoneListRequest) Region(region []RegionCode) ApiZoneListRequest {
	r.region = &region
	return r
}

// Zone type
func (r ApiZoneListRequest) Type_(type_ []string) ApiZoneListRequest {
	r.type_ = &type_
	return r
}

// Point (latitude,longitude)
func (r ApiZoneListRequest) Point(point string) ApiZoneListRequest {
	r.point = &point
	return r
}

// Include geometry in results (true/false)
func (r ApiZoneListRequest) IncludeGeometry(includeGeometry bool) ApiZoneListRequest {
	r.includeGeometry = &includeGeometry
	return r
}

// Limit
func (r ApiZoneListRequest) Limit(limit int32) ApiZoneListRequest {
	r.limit = &limit
	return r
}

// Effective date/time
func (r ApiZoneListRequest) Effective(effective time.Time) ApiZoneListRequest {
	r.effective = &effective
	return r
}

func (r ApiZoneListRequest) Execute() (*ZoneCollectionGeoJson, *http.Response, error) {
	return r.ApiService.ZoneListExecute(r)
}

/*
ZoneList Method for ZoneList

Returns a list of zones

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoneListRequest
*/
func (a *DefaultApiService) ZoneList(ctx context.Context) ApiZoneListRequest {
	return ApiZoneListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ZoneCollectionGeoJson
func (a *DefaultApiService) ZoneListExecute(r ApiZoneListRequest) (*ZoneCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ZoneList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.area != nil {
		localVarQueryParams.Add("area", parameterToString(*r.area, "csv"))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, "csv"))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, "csv"))
	}
	if r.point != nil {
		localVarQueryParams.Add("point", parameterToString(*r.point, ""))
	}
	if r.includeGeometry != nil {
		localVarQueryParams.Add("include_geometry", parameterToString(*r.includeGeometry, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.effective != nil {
		localVarQueryParams.Add("effective", parameterToString(*r.effective, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoneListTypeRequest struct {
	ctx context.Context
	ApiService DefaultApi
	type_ string
	id *[]string
	area *[]AreaCode
	region *[]RegionCode
	type_2 *[]string
	point *string
	includeGeometry *bool
	limit *int32
	effective *time.Time
}

// Zone ID (forecast or county)
func (r ApiZoneListTypeRequest) Id(id []string) ApiZoneListTypeRequest {
	r.id = &id
	return r
}

// State/marine area code
func (r ApiZoneListTypeRequest) Area(area []AreaCode) ApiZoneListTypeRequest {
	r.area = &area
	return r
}

// Region code
func (r ApiZoneListTypeRequest) Region(region []RegionCode) ApiZoneListTypeRequest {
	r.region = &region
	return r
}

// Zone type
func (r ApiZoneListTypeRequest) Type_2(type_2 []string) ApiZoneListTypeRequest {
	r.type_2 = &type_2
	return r
}

// Point (latitude,longitude)
func (r ApiZoneListTypeRequest) Point(point string) ApiZoneListTypeRequest {
	r.point = &point
	return r
}

// Include geometry in results (true/false)
func (r ApiZoneListTypeRequest) IncludeGeometry(includeGeometry bool) ApiZoneListTypeRequest {
	r.includeGeometry = &includeGeometry
	return r
}

// Limit
func (r ApiZoneListTypeRequest) Limit(limit int32) ApiZoneListTypeRequest {
	r.limit = &limit
	return r
}

// Effective date/time
func (r ApiZoneListTypeRequest) Effective(effective time.Time) ApiZoneListTypeRequest {
	r.effective = &effective
	return r
}

func (r ApiZoneListTypeRequest) Execute() (*ZoneCollectionGeoJson, *http.Response, error) {
	return r.ApiService.ZoneListTypeExecute(r)
}

/*
ZoneListType Method for ZoneListType

Returns a list of zones of a given type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Zone type
 @return ApiZoneListTypeRequest
*/
func (a *DefaultApiService) ZoneListType(ctx context.Context, type_ string) ApiZoneListTypeRequest {
	return ApiZoneListTypeRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ZoneCollectionGeoJson
func (a *DefaultApiService) ZoneListTypeExecute(r ApiZoneListTypeRequest) (*ZoneCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ZoneListType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterToString(r.type_, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.area != nil {
		localVarQueryParams.Add("area", parameterToString(*r.area, "csv"))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, "csv"))
	}
	if r.type_2 != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_2, "csv"))
	}
	if r.point != nil {
		localVarQueryParams.Add("point", parameterToString(*r.point, ""))
	}
	if r.includeGeometry != nil {
		localVarQueryParams.Add("include_geometry", parameterToString(*r.includeGeometry, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.effective != nil {
		localVarQueryParams.Add("effective", parameterToString(*r.effective, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoneObsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	zoneId string
	start *time.Time
	end *time.Time
	limit *int32
}

// Start date/time
func (r ApiZoneObsRequest) Start(start time.Time) ApiZoneObsRequest {
	r.start = &start
	return r
}

// End date/time
func (r ApiZoneObsRequest) End(end time.Time) ApiZoneObsRequest {
	r.end = &end
	return r
}

// Limit
func (r ApiZoneObsRequest) Limit(limit int32) ApiZoneObsRequest {
	r.limit = &limit
	return r
}

func (r ApiZoneObsRequest) Execute() (*ObservationCollectionGeoJson, *http.Response, error) {
	return r.ApiService.ZoneObsExecute(r)
}

/*
ZoneObs Method for ZoneObs

Returns a list of observations for a given zone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId NWS public zone/county identifier
 @return ApiZoneObsRequest
*/
func (a *DefaultApiService) ZoneObs(ctx context.Context, zoneId string) ApiZoneObsRequest {
	return ApiZoneObsRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return ObservationCollectionGeoJson
func (a *DefaultApiService) ZoneObsExecute(r ApiZoneObsRequest) (*ObservationCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ZoneObs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/forecast/{zoneId}/observations"
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(parameterToString(r.zoneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoneStationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	zoneId string
}

func (r ApiZoneStationsRequest) Execute() (*ObservationStationCollectionGeoJson, *http.Response, error) {
	return r.ApiService.ZoneStationsExecute(r)
}

/*
ZoneStations Method for ZoneStations

Returns a list of observation stations for a given zone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId NWS public zone/county identifier
 @return ApiZoneStationsRequest
*/
func (a *DefaultApiService) ZoneStations(ctx context.Context, zoneId string) ApiZoneStationsRequest {
	return ApiZoneStationsRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return ObservationStationCollectionGeoJson
func (a *DefaultApiService) ZoneStationsExecute(r ApiZoneStationsRequest) (*ObservationStationCollectionGeoJson, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObservationStationCollectionGeoJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ZoneStations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/forecast/{zoneId}/stations"
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(parameterToString(r.zoneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/ld+json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["userAgent"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["User-Agent"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetail
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
